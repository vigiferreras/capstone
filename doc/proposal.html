<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Virginia Ferreras">
<meta name="dcterms.date" content="2024-02-08">

<title>Proposal: The Curse of the Grammys</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="proposal_files/libs/clipboard/clipboard.min.js"></script>
<script src="proposal_files/libs/quarto-html/quarto.js"></script>
<script src="proposal_files/libs/quarto-html/popper.min.js"></script>
<script src="proposal_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="proposal_files/libs/quarto-html/anchor.min.js"></script>
<link href="proposal_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="proposal_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="proposal_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="proposal_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="proposal_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Proposal: The Curse of the Grammys</h1>
<p class="subtitle lead">DATA 450 Capstone</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Virginia Ferreras </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 8, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Music is a beautiful art that combines sounds and vocals to create forms of expression. Considered a universal language, music has been around for centuries and has evolved to a plethora of different genres. Music artists use music to express not only themselves, but their cultures and creativity. While music is subjective, there are a variety of different ways these musical artists get recognized and rewarded for their works of art. The Grammys is one of the most prestigious awards shows in the music industry, presented by the Recording Academy of the United States. With over 90 different awards, there are many different categories that shine light on the hard work and dedication of the people behind popular bodies of music. The most important awards of the ceremony, titled The “Big Four” are: Album of the Year, Song of the Year, Record of the Year, and Best New Artist.</p>
<p>Of these categories many people wait to see the winner of the Best New Artist award, as it gives upcoming artists a chance to be recognized for their talents. However, this award is also tied to what some may call a curse. Many people speculate that if an artist is awarded this award, then their careers are short lived after, therefore introducing the Best New Artist curse. While the impact these artists may have had on the music industry will still be placed on their respective pedestal, the curse basically points to the decline of their musical achievements, successes, and relevancy after receiving this award. Being an avid music listener and a fan of many different artists, I have always found myself curious about the validity of this curse. In this project, I am going to combine my knowledge of data science with my adoration of music and look into this curse. I want to prove whether or not this curse is true, and if so see if there is a pattern to which artists have fallen off after receiving this award.</p>
</section>
<section id="dataset" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Dataset</h1>
<p>The datasets that I will be using for this project are listed below.</p>
<p><strong>‘best_new.csv’</strong>: This dataset was created using information found on the Grammy’s official website. I entered the name of the artists who won the Best New Artist award along with the respective year of the win. There are 43 observations and 2 features found in this dataset, with the date being 1980-2022. The data was found through the <a href="https://www.grammy.com/awards">Grammy’s Official Website</a>.</p>
<p><strong>‘chart_data.csv’</strong>: The dataset was created by utilizing the Billboard’s Hot 100’s Chart. I went ahead and used web scraping to scrape each weekly chart from the week of February 3, 2024 back to October 12, 1985. There are 200,000 observations in this dataset and 5 features in this dataset. The features include: ‘week_of, ‘rank’, ‘song_title’, ‘artist_name’, ‘peak_position’. The data was found through the <a href="https://www.billboard.com/charts/hot-100/">Billboard Official Website</a>.</p>
<p><strong>‘spotify_api.csv’</strong>: This dataset contains several features found through the Spotify API (explained in the next section). There will be 6 features and 43 observations in the dataset. The features include: ‘artist_name’, ‘artist_genre’, ‘album_name’, ‘album_year’, ‘artist_followers’, ‘artist_popularity’. The data was found through the <a href="https://developer.spotify.com/documentation/web-api">Spotify for Developers website</a>.</p>
<p><strong>‘ama_winners.csv’</strong>: This dataset will be created by using web scraping techniques to gather the past American Music Award artists who have won an award. There will be 3 features on this dataset that include: ‘year_win’, ‘ama_category’, ‘artist_name’. The dataset was found through the official <a href="https://www.theamas.com/winners-database/">American Music Award website</a>.</p>
<p><strong>‘bma_winners.csv’</strong>: This dataset will be created by using web scraping techniques to gather the past Billboard Music Award artists who have won an award. There will be 3 features on this dataset that include: ‘year_win’, ‘bma_category’, ‘artist_name’. The dataset was found through the official <a href="https://www.billboardmusicawards.com/winners-database/?winnerKeyword=&amp;winnerYear=">Billboard Music Award website</a>.</p>
<p>*<strong>Variable Explanations:</strong></p>
<ul>
<li>artist_name: Name of the music artist</li>
<li>week_of: The week of the Billboard Hot 100s chart</li>
<li>‘rank’: The rank of the song on the Billboard Hot 100s chart during that week</li>
<li>‘song_title’: Title of the song on the chart</li>
<li>‘peak_position’: The peak rank that song has had on a Billboard Hot 100’s chart.</li>
<li>‘artist_genre’: Genre/s that are associated with the artist</li>
<li>‘album_name’: Name/s of the albums released by the artist</li>
<li>‘album_year’: Year of an albums release</li>
<li>‘artist_followers’: The amount of followers an artist has on Spotify</li>
<li>‘artist_popularity’: The popularity of an artist, which will be indicated by a value between 0 and 100 with 100 being the most popular. This value is calculated from the popularity of the artist tracks. This popularity is calculated by a mathematical algorithm the Spotify API follows, which for the most part is based on the total number of plays a track has and how recent the plays were.</li>
<li>‘ama_category’: American Music Award award category.</li>
<li>‘bma_category’: Billboard Music Award award category.</li>
</ul>
</section>
<section id="data-acquisition-and-processing" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Data Acquisition and Processing</h1>
<p>In order to gather the data of the past Grammy Best New Artist winners, I manually entered the artist names and the years they won into an Excel spreadsheet. Once compiled, I converted this spreadsheet into a CSV file.</p>
<p>The Billboard Hot 100s in the music industry’s record chart for the United States that is updated weekly. This is a very respected and reputable chart that the music artists and teams use to rank a song’s popularity. I want to use these charts to be my main indication of how well an artist does after winning this award. The more singles an artist lands on the charts, the more relevancy and popularity they maintain or grow. To gather data on the Billboard Hot 100s charts, I utilized web scraping techniques. Using the BeautifulSoup library to parse HTML, requests package to make HTTP requests, and the datetime package to handle dates, I navigated through each year’s chart, scraping the necessary data needed. After collecting this data, I utilized the Pandas library to create a dataframe, which was then saved to a CSV file.</p>
<p>While the Grammys is one of the most prestigious music awards in the industry, there are other awards that are as important and well-respected in the music industry. Along with the Grammys, the American Music Awards and the Billboard Music Awards make the”Big Three” major music awards. Therefore, I decided to analyze if these artists have won any awards in these award shows after winning the Best New Artist award. The same scraping method was employed to gather information on past winners of the American Music Awards past winners and Billboard Music Awards.</p>
<p>Spotify is one of the largest and most popular music streaming platforms used by the public. They house a plethora of information regarding different artists on their free API. Therefore, I wanted to utilize this data in order to deepen my future investigations. I accessed the free API system provided by Spotify using my personal Spotify account information to gather more data on the respective artists, including information such as artist genre, album names, release years, followers, and popularity. After compiling the data, I used Pandas to create a dataframe, and then saved the CSV file.</p>
</section>
<section id="data-processing" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Data Processing:</h1>
<p>Since the datasets I am working with are already saved as CSV files, I do not have to adjust any of the file formats. After reading my data files using the Pandas file, I will go ahead and begin the process tidying up the data.</p>
<ol type="1">
<li><p><strong>Adjusting Column headers:</strong> Since I gathered the data being used for this project, the column headers are already written in a preferred format. However, if needed I will go ahead and adjust column headers to better facilitate future modeling and analysis.</p></li>
<li><p><strong>Data Types:</strong> I will check the data types of each dataset and ensure that each feature has the correct data type that will not hinder any future analysis.</p></li>
<li><p><strong>Data Encoding:</strong> I will be encoding one variable found in the spotify_api dataset. The genre variable will be investigated during the modeling stage, so I will use one-hot encoding to label each genre as a unique number. This method will help me handle artists associated with a variety of genres.</p></li>
<li><p><strong>Data Ranking:</strong> Utilizing the ‘rank()’ function from the Pandas library, I will be assigning rankings to the ‘peak_position’ feature, which represents the highest chart position a single has had on the chart (with 1 being the highest).</p></li>
<li><p><strong>Handling Missing Values:</strong> The only feature that has missing values is ‘peak_position’ due to songs that have never charted, thus lacking a peak position. In this case, instead of imputing these missing values with the mean, median, or mode, which would be misleading, I will instead use a placeholder value and impute with the maximum possible value. This preserves the integrity of the data by not assigning artists peak positions that they have never had.</p></li>
<li><p><strong>New Datasets:</strong> After tidying the datasets, I will create new data frames that contain only the artists who have won the Best New Artist award from the ‘chart_data’, ‘ama_winners’, and ‘bma_winners’ datasets. This will allow me to focus exclusively on these relevant artists, making future modeling more efficient.</p></li>
</ol>
<p>Additionally, I will create a new dataset consisting of the artist name and the count of singles, AMA awards, and BMA awards received. This dataset will be merged with the ‘spotify_api’ dataset to provide an overview of the artist’s popularity, and other relevant information. This will make future visualizations easier to create, and it will place the counts of the awards of an artist in one place.</p>
</section>
<section id="research-questions-and-methodology" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Research Questions and Methodology</h1>
<p>I will be investigating three research questions, which are listed below along with the process of how I will answer these questions.</p>
<p><strong>Question 1: Does the success of an artist’s career decrease after winning this award?</strong> One way I will determine the success of an artist is by looking at the number of singles they have had on the Billboard Hot 100s after winning the Best New Artist award. I will visualize these counts by utilizing Plotly to create an interactive line plot in order to choose which artist you want to see represented on the line chart. The y-axis will be the number of singles, and the x-axis will be the year difference. I will analyze these lines to see if there are any patterns with the number of singles an artist has on the billboard Hot 100s after they win the award.</p>
<pre><code>Another way I will determine the success of an artist is by looking at the number of awards they have received in the American Music Awards and Billboards Music Awards (the two other important music award shows). I will use a stacked bar plot to visualize the number of awards these artists received after winning the Best New Artist Award. I will also use the same line plot that was used to visualize the Hot 100 singles count. This way, I can look at each artist individually and see the total number of awards they’ve one since winning the Best New Artist award.</code></pre>
<p><strong>Question 2: Are there any features that affect the success of an artist’s career after winning this award?</strong> To answer this question, I will use predictive modeling to predict what features have the most effect on an artist’s career. A decision tree, random forest, and linear regression will be used to come to a conclusion. I will test its accuracy and ensure that the training and testing data is properly split before starting the modeling process.These models will be able to provide us with a list of the top features that have an effect on the target variable (artist’s popularity).</p>
<p><strong>Question 3: Are there differences in the success through an artist’s career of the Best New Artist winners across different music genres?</strong> In this question, I will be veering away from artists and looking more into a music genres’ possible impact on an artist’s career. I will create a bar plot that showcases the number of award each genre has won, as well as another bar plot that visualizes the number of singles on the Hot 100s of these genres.</p>
</section>
<section id="work-plan" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Work plan</h1>
<p><strong>Week 4 (2/12 - 2/18):</strong></p>
<ul>
<li><p>Scraping the American Music Awards and Billbord Music Awards data (2 hours)</p></li>
<li><p>Gathering Spotify API data (1.5 hours)</p></li>
<li><p>Adjusting/handling column headers, data types, missing values and creating new necessary dataframes (4 hours)</p></li>
</ul>
<p><strong>Week 5 (2/19 - 2/25):</strong></p>
<ul>
<li><p>Data encoding and ranking (1 hours)</p></li>
<li><p>Question 1: Line plot (2.5 hours)</p></li>
<li><p>Question 1: Bar plot (1.5 hours)</p></li>
<li><p>Question 2: Start decision tree and random forest models (2 hours)</p></li>
</ul>
<p><strong>Week 6 (2/26 - 3/3):</strong></p>
<ul>
<li><p>Question 1: Adjustments (1 hours)</p></li>
<li><p>Question 2: Linear regression (3 hours)</p></li>
<li><p>Question 3: Both bar plots (4 hours)</p></li>
</ul>
<p><strong>Week 7 (3/4 - 3/10):</strong></p>
<ul>
<li><p>Question 1, 2, and 3: Adjustments (2 hour)</p></li>
<li><p>Presentation prep and practice (5 hours)</p></li>
</ul>
<p><strong>Week 8 (3/11 - 3/17):</strong> <em>Presentations given on Wed-Thu 3/13-3/14. Poster Draft due Friday 3/15 (optional extension till 3/17).</em></p>
<ul>
<li><p>Any last minute presentation prep (2 hours)</p></li>
<li><p>Poster prep (5 hours)</p></li>
<li><p>Presentation peer review (1.5 hours)</p></li>
</ul>
<p><strong>Week 9 (3/25 - 3/31):</strong> <em>Final Poster due Sunday 3/31</em>.</p>
<ul>
<li><p>Peer feedback (3.5 hours)</p></li>
<li><p>Poster revisions (3.5 hours)</p></li>
</ul>
<p><strong>Week 10 (4/1 - 4/7):</strong></p>
<ul>
<li><p>Blog Post: Draft (3 hours)</p></li>
<li><p>Any changes/adjustments (4 hours)</p></li>
</ul>
<p><strong>Week 11 (4/8 - 4/14):</strong></p>
<ul>
<li><p>Blog Post: Draft (4 hours)</p></li>
<li><p>Any changes/adjustments (4 hours)</p></li>
</ul>
<p><strong>Week 12 (4/15 - 4/21):</strong></p>
<ul>
<li><p>Final changes and adjustments to code (2 hours)</p></li>
<li><p>Code clean-up/organization (4 hours)</p></li>
<li><p>Blog Post: Draft (2 hours)</p></li>
</ul>
<p><strong>Week 13 (4/22 - 4/28):</strong> <em>Blog post draft 1 due Sunday night 4/28.</em> [All project work should be done by the end of this week. The remaining time will be used for writing up and presenting your results.]</p>
<ul>
<li>Draft blog post (4 hours).</li>
</ul>
<p><strong>Week 14 (4/29 - 5/5):</strong></p>
<ul>
<li><p>Peer feedback (3 hours)</p></li>
<li><p>Blog post revisions (4 hours)</p></li>
</ul>
<p><strong>Week 15 (5/6 - 5/12):</strong> *Final blog post due Weds 5/8. Blog post read-throughs during final exam slot, Thursday May 9th, 8:00-11:20am.</p>
<ul>
<li><p>Blog post revisions (2 hours)</p></li>
<li><p>Peer feedback (2 hours)</p></li>
</ul>
</section>
<section id="references" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> References</h1>
<p>“Award Nominations and Winners” grammy.com. https://www.grammy.com/awards (accessed Feb.&nbsp;8, 2024).</p>
<p>“Billboard Hot 100s” billboard.com. https://www.billboard.com/charts/hot-100/ (accessed Feb.&nbsp;8, 2024).</p>
<p>“Winners Database” theamas.com. https://www.theamas.com/winners-database/ (accessed Feb.&nbsp;8, 2024).</p>
<p>“Winners Database” billboardmusicawards.com. https://www.billboardmusicawards.com/winners-database/ (accessed Feb.&nbsp;8, 2024).</p>
<p>“Spotify for Developers” developer.spotify.com. https://developer.spotify.com/ (accessed Feb.&nbsp;8, 2024).</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>